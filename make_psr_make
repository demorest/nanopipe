#! /usr/bin/env python

# Create pulsar timing makefile
# This is somewhat specific to guppi/puppi files which have names like:
#  guppi_56249_J1713+0747_0004_0001.fits
#  guppi_56249_J1713+0747_0006_cal_0001.fits

#######################################################################
# Configuration section
#######################################################################

# Filename extensions of the raw input files
raw_ext = "fits"

# Log any calibration failures in this file
cal_fail = 'cal_failures.list'

# Files containing list of files and/or scans to ignore
ignore_files = ['../files.ignore', cal_fail]

# Standard zap commands (paz arguments) to apply per receiver
# 'default' is applied to any reciever not listed
zap = {
        'Rcvr1_2':'-F "1100 1150" -F "1250 1262" -F "1288 1300" -F "1373 1381" -F "1442 1447" -F "1525 1558" -F "1575 1577" -F "1615 1630" -F "1370 1385"',
        'Rcvr_800':'-F "794.6 798.6" -F "814.1 820.7"',
        '327':'',
        '430':'-F "380 420" -F "446 480"',
        'L-wide':'-F "980 1150" -F "1618 1630"',
        'S-wide':'-F "1600 1770" -F "1880 2050" -F "2400 2600"',
        'default':''
    }

# Calibration method (pac options) to apply for each receiver
# Multiple options per reciever can be specified.
# 'default' is applied for receivers not explicitly listed. 
cal_methods = {'Rcvr1_2':['x','S'],'default':['x']}

# Frequency scrunch commands (pam options) to apply in order
# to reduce the data to the final resolution desired for TOAs.
fscrunch_arg = {'327':'', '430':'', 'Rcvr_800':'-f2', 'Rcvr1_2':'-f8', 
        'L-wide':'-f8', 'S-wide':'-f8', 'default':'--setnchn=64'}

# Allow any of these to be redefined in a local config file
try:
    execfile('../make_psr_make.config.py')
except IOError:
    pass

#######################################################################
# End of config section
#######################################################################

import os, sys, glob, string
import psrchive

# List of original input files, they are assumed to all have the 
# given extension.
inputs = glob.glob("*." + raw_ext)

# Ignore file can contain either full *.fits filenames to ignore,
# or just the base part of the scan.
ignores = []
for fname in ignore_files:
    try: 
        ignores.extend([x.strip() for x in open(fname).readlines()])
    except: 
        pass

# Strip out any ignored files
inputs = [x for x in inputs if x not in ignores]

def get(d,k,default='default'):
    if k in d.keys(): return d[k]
    else: return d[default]

# Return the 'base' part of file name
def basename(full):
    noext = full.replace('.'+raw_ext,'')
    if noext.find('uppi') == -1:
        return noext
    parts = noext.split('_')
    if parts[4] == 'cal': 
        return noext
    else: 
        return string.join(parts[0:4],'_')

# Return the full filename for 1st file in scan set
def fullname(base):
    if base.find('uppi') == -1:
        return base + '.' + raw_ext
    else:
        if base.find('cal') == -1:
            return base + "_0001." + raw_ext
        else:
            return base + '.' + raw_ext

# List of unique base filenames (eg, scans)
scans = list(set(map(basename,inputs)))

# Strip out ignored scans
scans = [x for x in scans if x not in ignores]

# Separate into cal and psr, get any necessary info
psrchive.Profile.no_amps.fset(True)
calscans = []
psrscans = []
rcvrs = {}
for sc in scans:
    arch = psrchive.Archive_load(fullname(sc))
    if arch.get_type() == "PolnCal":
        calscans.append(sc)
    elif arch.get_type() == "Pulsar":
        psrscans.append(sc)
        rcvrs[sc] = arch.get_receiver_name()

# Assume for now that all files are of a single source
# Get it from the first file in the list
# Same for backend
# TODO make get_proper_name a library func..
arch = psrchive.Archive_load(inputs[0])
#srcname = arch.get_source()
srcname = os.popen('get_proper_name ' + inputs[0]).read().rstrip()
backend = arch.get_backend_name()

# Lists of psr scans by recvr
rcvrscans = {}
rcvrnames = list(set(rcvrs.values()))
for r in rcvrnames:
    rcvrscans[r] = [x for x in psrscans if rcvrs[x]==r]

# Print an informative Makefile header
print """# NOTE:
# This makefile was automatically generated by the make_psr_make
# script.  It will try to update itself if it finds new data files
# available, so any changes made here will likely be overwritten.
# 
# Working dir '%s'
# Source name '%s'
#
# To generate calibrated files:
#    make -f Make.psr
# To generate templates for timing:
#    make -f Make.psr templates
# To generate toas:
#    make -f Make.psr toas
#
# (-j, -k, and other standard make options can be used as desired)
""" % (os.getcwd(), srcname)

# Makefile targets
targets = {}
targets['all'] = []
targets['templates'] = []
targets['toas'] = []
print ".DEFAULT_GOAL := all"

# Update the makefile
mfile = 'Make.psr'
makemake = '../make_psr_make'
print mfile + ": *." + raw_ext + " " + makemake
print "\t" + makemake + " > $@"

# Make the tscrunched cal files with cf extension
print "%.cf: %." + raw_ext + "\n\tpam -e cf -T $<"
cfs = map(lambda x: x+'.cf', calscans)
print ".PHONY: all cf templates toas"
targets['cf'] = cfs
targets['all'].append('cf')
dbfile = "../database.txt"

# Update the psrchive cal database
print dbfile + ": " + string.join(cfs) + "\n\tpac -w -p .."
targets['all'].append(dbfile)

# Make the combined .rf files
print "%.rf:\n\tpsradd -j 'T x8' -j \"e name=`get_proper_name $^`\" -o $@ $^"
targets['all'].extend(map(lambda x: x+'.rf', psrscans))
for sc in psrscans:
    targets[sc+'.rf'] = sorted([x for x in inputs if sc in x])

# Calibrated files
# Note these depend on fluxcals also but we'll ignore that for now.
# Also note that we don't track which specific cal files each scan
# depends on.  Instead, the 'order-only' cf prereq makes sure all the
# cal scans are processed before any psr scans are calibrated.
calib_scans = {}
for r in rcvrnames:
    cm = get(cal_methods,r)
    z = get(zap,r)
    calib_scans[r] = []
    for c in cm:
        ext = c + ".calib"
        calib_scans[r].extend(map(lambda x: x+'.'+c, rcvrscans[r]))
        calib_files = map(lambda x: x+'.'+ext, rcvrscans[r])
        print "\n# Calibration for receiver '%s':" % (r)
        print string.join(calib_files)+": %."+ext+": %.rf | cf "+ dbfile
        print "\tpac -Ta"+c+" -e "+ext+" -d "+dbfile + " $<"
        print "\ttest -e $@ && paz -m -E2.0 " + z + " $@ || echo $* >> " + cal_fail
        targets['all'].extend(calib_files)

all_calib_scans = []
for r in rcvrnames: all_calib_scans.extend(calib_scans[r])

# Extra zapping
print "\n%.zap: %.calib\n\tpsrsh -e zap ../zap_minmax $<"
targets['all'].extend(map(lambda x: x+'.zap', all_calib_scans))

# Normalize by off-pulse RMS
print "\n%.norm: %.zap\n\tnormalize_rms $<"
targets['all'].extend(map(lambda x: x+'.norm', all_calib_scans))

# Make final partly scrunched version for TOAs, different scrunch
# per rcvr
for r in rcvrnames:
    files = map(lambda x: x+'.ff', calib_scans[r])
    f = get(fscrunch_arg,r)
    print string.join(files)+": %.ff: %.norm\n\tpam -e ff "+f+" -t8 $<"
    targets['all'].extend(files)

# Generate template files and TOAs.
# This will currently regenerate all TOAs anytime anything changes..
print "%.sum:\n\tautotoa -g0.1 -i3 -S $@ $^\n\tpam -r0.5 -m $@"
print "%.sm: %\n\tpsrsmooth -W -t UD8 $<"
print "%.tim: %.sum.sm\n\techo 'MODE 1' > $@\n\tpat -f princeton -s $^ >> $@"
for r in rcvrnames:
    cm = get(cal_methods,r)
    for c in cm:
        tmpl = '%s.%s.%s.%s.sum' % (srcname,r,backend,c)
        tmpl_sm = tmpl + '.sm'
        targets['templates'].append(tmpl)
        targets['templates'].append(tmpl_sm)
        targets[tmpl] = map(lambda x: x+'.'+c+'.ff', rcvrscans[r])

        toa = '%s.%s.%s.%s.tim' % (srcname,r,backend,c)
        targets['toas'].append(toa)
        targets[toa] = map(lambda x: x+'.'+c+'.ff', rcvrscans[r])

# Print all the dependencies
print "\n# Dependencies:"
for t in targets.keys():
    print t + ": " + string.join(targets[t])
