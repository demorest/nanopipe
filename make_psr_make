#! /usr/bin/env python

# Create pulsar timing makefile
# This is somewhat specific to guppi/puppi files which have names like:
#  guppi_56249_J1713+0747_0004_0001.fits
#  guppi_56249_J1713+0747_0006_cal_0001.fits

import os, sys, glob, string
import psrchive

# List of original input files, they are assumed to all have the 
# given extension.
raw_ext = "fits"
inputs = glob.glob("*." + raw_ext)

# Ignore file can contain either full *.fits filenames to ignore,
# or just the base part of the scan.
ignores = []
try:
    ignores = [x.strip() for x in open('../files.ignore').readlines()]
except:
    pass

# Strip out any ignored files
inputs = [x for x in inputs if x not in ignores]

# Return the 'base' part of file name
def basename(full):
    noext = full.replace('.'+raw_ext,'')
    parts = noext.split('_')
    if parts[4] == 'cal': 
        return noext
    else: 
        return string.join(parts[0:4],'_')

# List of unique base filenames (eg, scans)
scans = list(set(map(basename,inputs)))

# Strip out ignored scans
scans = [x for x in scans if x not in ignores]

# Separate into cal and psr
calscans = [x for x in scans if 'cal' in x]
psrscans = [x for x in scans if not 'cal' in x]

# Get some info about scans
psrchive.Profile.no_amps.fset(True)
rcvrs = {}
for sc in psrscans:
    rcvrs[sc] = psrchive.Archive_load(sc+"_0001."+raw_ext).get_receiver_name()

# Assume for now that all files are of a single source
# Get it from the first file in the list
srcname = psrchive.Archive_load(psrscans[0]+"_0001."+raw_ext).get_source()

# Lists of psr scans by recvr
rcvrscans = {}
rcvrnames = list(set(rcvrs.values()))
for r in rcvrnames:
    rcvrscans[r] = [x for x in psrscans if rcvrs[x]==r]

# Print an informative Makefile header
print """# NOTE:
# This makefile was automatically generated by the make_psr_make
# script.  It will try to update itself if it finds new data files
# available, so any changes made here will likely be overwritten.
# 
# Working dir '%s'
# Source name '%s'
#
# To generate calibrated files:
#    make -f Make.psr
# To generate templates for timing:
#    make -f Make.psr templates
# To generate toas:
#    make -f Make.psr toas
#
# (-j, -k, and other standard make options can be used as desired)
""" % (os.getcwd(), srcname)

# Makefile targets
targets = {}
targets['all'] = []
targets['templates'] = []
targets['toas'] = []
print ".DEFAULT_GOAL := all"

# Update the makefile
mfile = 'Make.psr'
makemake = '../make_psr_make'
print mfile + ": *." + raw_ext + " " + makemake
print "\t" + makemake + " > $@"

# Make the tscrunched cal files with cf extension
print "%.cf: %." + raw_ext + "\n\tpam -e cf -T $<"
cfs = map(lambda x: x+'.cf', calscans)
print ".PHONY: all cf templates toas"
targets['cf'] = cfs
targets['all'].append('cf')
dbfile = "../database.txt"

# Update the psrchive cal database
print dbfile + ": " + string.join(cfs) + "\n\tpac -w -p .."
targets['all'].append(dbfile)

# Make the combined .rf files
print "%.rf:\n\tpsradd -j 'T x8' -o $@ $^"
targets['all'].extend(map(lambda x: x+'.rf', psrscans))
for sc in psrscans:
    targets[sc+'.rf'] = sorted([x for x in inputs if sc in x])

# Calibrated files
# Note these depend on fluxcals also but we'll ignore that for now.
# Also note that we don't track which specific cal files each scan
# depends on.  Instead, the 'order-only' cf prereq makes sure all the
# cal scans are processed before any psr scans are calibrated.
# TODO need to deal with per-receiver zap ranges since L and S 
# overlap at Arecibo...
print "%.x.calib: %.rf | cf " + dbfile + "\n\tpac -Tax -e x.calib -d " + dbfile + " $<"
stdzap_gbt = 'paz -m -E 2.0 -F "794.6 798.6" -F "814.1 820.7" -F "1100 1150" -F "1250 1262" -F "1288 1300" -F "1373 1381" -F "1442 1447" -F "1525 1558" -F "1575 1577" -F "1615 1630" -F "1370 1385" $@'
stdzap_ao = 'paz -m -E 2.0 -F "380 420" -F "446 480" -F "980 1150" -F "1618 1630" -F "1880 2050" $@'
stdzap = stdzap_ao # TODO fix me!
print "\t" + stdzap
all_calib_files = map(lambda x: x+'.x', psrscans)

# PCM-calibrated files, only for L-band so far
print "%.S.calib: %.rf | cf " + dbfile + "\n\tpac -TaS -e S.calib -d " + dbfile + " $<"
print "\t" + stdzap
if rcvrscans.has_key('Rcvr1_2'):
    all_calib_files.extend(map(lambda x: x+'.S', rcvrscans['Rcvr1_2']))

# Add all calibrated files to final target list
targets['all'].extend(map(lambda x: x+'.calib', all_calib_files))

# Extra zapping
print "%.zap: %.calib\n\tpsrsh -e zap ../zap_minmax $<"
targets['all'].extend(map(lambda x: x+'.zap', all_calib_files))

# Normalize by off-pulse RMS
print "%.norm: %.zap\n\tnormalize_rms $<"
targets['all'].extend(map(lambda x: x+'.norm', all_calib_files))

# Make final partly scrunched version for TOAs
#print "%.ff: %.norm\n\tpam -e ff -f8 -t8 $<"
print "%.ff: %.norm\n\tpam -e ff --setnchn=64 -t8 $<"
targets['all'].extend(map(lambda x: x+'.ff', all_calib_files))

# Generate template files and TOAs.
# This will currently regenerate all TOAs anytime anything changes..
print "%.sum:\n\tautotoa -g0.1 -i3 -S $@ $^\n\tpam -r0.5 -m $@"
print "%.sm: %\n\tpsrsmooth -W -t UD8 $<"
print "%.tim: %.sum.sm\n\techo 'MODE 1' > $@\n\tpat -f princeton -s $^ >> $@"
for r in rcvrnames:
    calmthds = ['x']
    if (r=='Rcvr1_2'):
        calmthds = ['x','S']
    for c in calmthds:
        tmpl = '%s.%s.%s.sum' % (srcname,r,c)
        tmpl_sm = tmpl + '.sm'
        targets['templates'].append(tmpl)
        targets['templates'].append(tmpl_sm)
        targets[tmpl] = map(lambda x: x+'.'+c+'.ff', rcvrscans[r])

        toa = '%s.%s.%s.tim' % (srcname,r,c)
        targets['toas'].append(toa)
        targets[toa] = map(lambda x: x+'.'+c+'.ff', rcvrscans[r])

# Print all the dependencies
for t in targets.keys():
    print t + ": " + string.join(targets[t])
